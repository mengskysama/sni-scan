package scanner

import (
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"
)

var (
	payload  []byte
	readBuff []byte
	stopped  bool
)

const (
	dialTimeout      = time.Second * 3
	detectReqTimeout = time.Second * 5
	handshakeMinSize = 512
)

func init() {
	readBuff = make([]byte, 1024)
	payload = []byte{
		0x16, 0x03, 0x01, 0x01, 0x05, 0x01, 0x00, 0x01, 0x01, 0x03, 0x03, 0x58, 0x77, 0x97, 0xcf, 0x96,
		0x6a, 0x2e, 0x84, 0x2f, 0x1c, 0x07, 0xf9, 0xda, 0x3b, 0x24, 0xae, 0xe2, 0x48, 0x38, 0x98, 0xbe,
		0xe5, 0x58, 0x92, 0xc9, 0xfb, 0x8b, 0x24, 0x08, 0xff, 0x46, 0xe7, 0x20, 0x12, 0x47, 0x1a, 0xc8,
		0x88, 0x73, 0xdb, 0x4a, 0x5e, 0xc6, 0x02, 0x57, 0x68, 0x46, 0xf6, 0xae, 0x66, 0xbd, 0x2b, 0x70,
		0x18, 0x67, 0x6c, 0x72, 0x3e, 0x13, 0xfe, 0xcf, 0x2e, 0xc2, 0x73, 0x98, 0x00, 0x38, 0xc0, 0x2c,
		0xc0, 0x30, 0x00, 0x9f, 0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f, 0x00, 0x9e,
		0xc0, 0x24, 0xc0, 0x28, 0x00, 0x6b, 0xc0, 0x23, 0xc0, 0x27, 0x00, 0x67, 0xc0, 0x0a, 0xc0, 0x14,
		0x00, 0x39, 0xc0, 0x09, 0xc0, 0x13, 0x00, 0x33, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d, 0x00, 0x3c,
		0x00, 0x35, 0x00, 0x2f, 0x00, 0xff, 0x01, 0x00, 0x00, 0x80, 0x00, 0x23, 0x00, 0x24, 0x80, 0x33,
		0x4d, 0xc8, 0x7a, 0x9f, 0x36, 0xc2, 0xce, 0xa1, 0xaf, 0xf9, 0x18, 0x05, 0x3d, 0x7a, 0x04, 0xae,
		0x16, 0xd1, 0x46, 0x71, 0x8d, 0x2f, 0x10, 0xfb, 0xa4, 0x70, 0xa0, 0xb0, 0x54, 0x68, 0xdf, 0xc3,
		0xa4, 0x2c, 0x00, 0x00, 0x00, 0x12, 0x00, 0x10, 0x00, 0x00, 0x0d, 0x77, 0x77, 0x77, 0x2e, 0x62,
		0x61, 0x69, 0x64, 0x75, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x01, 0x00, 0x02,
		0x00, 0x0a, 0x00, 0x0a, 0x00, 0x08, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x19, 0x00, 0x18, 0x00, 0x0d,
		0x00, 0x20, 0x00, 0x1e, 0x06, 0x01, 0x06, 0x02, 0x06, 0x03, 0x05, 0x01, 0x05, 0x02, 0x05, 0x03,
		0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02,
		0x02, 0x03, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00}

	c := make(chan os.Signal)
	signal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2)
	go func() {
		for s := range c {
			switch s {
			case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:
				fmt.Println("signal recv stopping ...")
				stopped = true
			}
		}
	}()
}

func FastDetect(sniProxy string) bool {
	conn, err := net.DialTimeout("tcp", sniProxy, dialTimeout)
	if err != nil {
		return false
	}

	_ = conn.SetDeadline(time.Now().Add(detectReqTimeout))
	_, err = conn.Write(payload)
	if err != nil {
		_ = conn.Close()
		return false
	}

	if n, _ := conn.Read(readBuff); n < handshakeMinSize {
		_ = conn.Close()
		return false
	}

	_ = conn.Close()
	return true
}

func Detect(sniProxy, targetURL string) bool {
	transport := &http.Transport{
		DialContext: func(ctx context.Context, network, addr string) (conn net.Conn, err error) {
			c, err := net.DialTimeout(network, sniProxy, dialTimeout)
			if err != nil {
				return nil, err
			}
			return c, nil
		},
	}
	client := http.Client{
		Transport: transport,
		Timeout: detectReqTimeout,
	}
	req, _ := http.NewRequest("GET", targetURL, nil)
	req.Header.Set("User-Agent", "Mozilla/5.0")
	_, err := client.Do(req)
	if err != nil {
		return false
	}
	return true
}

func Worker(targetURL string, task chan string, w *sync.WaitGroup) {
	for {
		select {
		case sniProxy, read := <-task:
			if !read {
				w.Done()
				return
			}
			if FastDetect(sniProxy) {
				if Detect(sniProxy, targetURL) {
					fmt.Printf("find sni %s\n", sniProxy)
					SNISummary.Add(sniProxy)
				}
			}
		}
	}
}

type scanTask struct {
	Begin, End int64
}

func LoadTask(taskFile string) (tasks []scanTask, n int64) {
	fileData, _ := ioutil.ReadFile(taskFile)
	lines := strings.Split(string(fileData), "\n")
	for _, prefix := range lines {
		prefix = strings.TrimSpace(prefix)
		if prefix == "" {
			continue
		}
		tmp := strings.Split(prefix, "//")
		tmp = strings.Split(tmp[0], "#")
		tmp = strings.Split(tmp[0], "/")
		if len(tmp) != 2 {
			fmt.Printf("ignore bad prefix %s\n", prefix)
			continue
		}
		startTarget, err := inetA2n(tmp[0])
		if err != nil {
			fmt.Printf("ignore bad prefix %s\n", prefix)
			continue
		}
		v, err := strconv.ParseInt(tmp[1], 10, 64)
		if err != nil {
			fmt.Printf("ignore bad prefix %s\n", prefix)
			continue
		}
		endTarget := startTarget + int64(1<<uint(32-v)) - 1
		t := scanTask{
			Begin: startTarget,
			End:   endTarget,
		}
		n += endTarget - startTarget + 1
		tasks = append(tasks, t)
	}
	return
}

func Dispatcher(tasks []scanTask, SNIPort string, taskCh chan string) {
	defer func() {
		close(taskCh)
	}()
	for _, task := range tasks {
		for task.Begin <= task.End {
			if stopped {
				return
			}
			ip := inetN2a(task.Begin).String()
			sniProxy := ip + ":"+ SNIPort
			taskCh <- sniProxy
			CounterSummary.Add(sniProxy)
			task.Begin++
		}
	}
}
